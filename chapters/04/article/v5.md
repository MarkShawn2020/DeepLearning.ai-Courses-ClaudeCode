

> 欢迎阅读[吴恩达与 Anthropic 联袂推出的 Claude Code 教程第四课](https://learn.deeplearning.ai/courses/claude-code-a-highly-agentic-coding-assistant/lesson/zzhtb/adding-features)手工川笔记，在这期教学里你讲见证一个 “高度智能（Highly Agentic）” 的编码助手如何从零到一地为项目添砖加瓦，希望对你有用。

### Key Insights

1.  **计划先行，谋定后动**：在着手新功能或复杂重构时，优先使用 “计划模式 (Plan Mode)”，让 AI 先思考、再执行，能显著提升代码质量与方向准确性。
2.  **精准上下文是效率的关键**：无论是通过 `@` 符号精确引用文件，还是利用截图进行多模态交流，为 AI 提供充足且准确的上下文，是获得高质量输出的根本。
3.  **“思考预算” 的妙用**：通过 `think`, `think harder` 等指令，我们可以主动提升 Claude Code 的 “思考预算”，迫使其在处理复杂问题时投入更多计算资源，从而获得更优解。
4.  **上下文工程 (Context Engineering)**：`/clear` 与 `/compact` 的选择并非小事。理解并实践上下文管理，是决定我们能否与 AI 进行长期、连贯且高效协作的核心技能。
5.  **MCP 协议拓展 AI 边界**：通过模型上下文协议 (MCP)，Claude Code 能够集成 Playwright 等外部工具，实现从 “理解” 到 “操作” 的跨越，自动化完成浏览器测试与调试，展现出惊人的智能体潜力。

## 好的 Prompt 是如何炼成的？

在整个教程中，我特别留意了 Elie 老师与 Claude Code 沟通时所使用的 prompt。一个好的 prompt，是开启 AI 强大能力的第一把钥匙。我将 Elie 老师使用的几个关键 prompt 截图罗列如下，并总结了我自己的一套 “Vibe Coding” 范式。

![](https://poketto.oss-cn-hangzhou.aliyuncs.com/0252f8a50df83f9df1204f27e87b6ed3.png?x-oss-process=image/quality,q_90/rotate,0)

![](https://poketto.oss-cn-hangzhou.aliyuncs.com/2e0cc5922079845941b1020de1fb00eb.png?x-oss-process=image/quality,q_90/rotate,0)

![](https://poketto.oss-cn-hangzhou.aliyuncs.com/ca16b1ac44df1040d7d8668290cde17d.png?x-oss-process=image/quality,q_90/rotate,0)

![](https://poketto.oss-cn-hangzhou.aliyuncs.com/2c37cc9cddf94007a51cec6a05809f91.png?x-oss-process=image/quality,q_90/rotate,0)

![](https://poketto.oss-cn-hangzhou.aliyuncs.com/f73fcea002422993739a37f8d933025d.png?x-oss-process=image/quality,q_90/rotate,0)

![](https://poketto.oss-cn-hangzhou.aliyuncs.com/41c48b5c2adc4d69620def2dea3cbfa0.png?x-oss-process=image/quality,q_90/rotate,0)

![](https://poketto.oss-cn-hangzhou.aliyuncs.com/4cb3a33b2094414e38480328a4481285.png?x-oss-process=image/quality,q_90/rotate,0)

观察这些 prompt，我总结出了一套 Vibe Coding 的心法，并将其划分为四个层次：

![](https://poketto.oss-cn-hangzhou.aliyuncs.com/71ae63768b46f2fa7c7b263acfd91a6f.png?x-oss-process=image/quality,q_90/rotate,0)

*   **L1. 我要Z**：这是最基础的层次，必须清晰、明确地告诉 AI 你的最终目标是什么。例如，“我要一个新聊天按钮”。
*   **L2. 现在是Y，我要Z**：在阐述目标的同时，告知 AI 当前的状况或上下文。例如，“这些链接的蓝色太深了（现状Y），让它们在视觉上更好看一些（目标Z）”。
*   **L3. 我做了X，现在是Y，我要Z**：在 L2 的基础上，补充你已经尝试过的操作 (X)，这可以帮助 AI 更好地理解问题，避免重复或错误的尝试。
*   **L4. 请基于W，实现Z**：这是最高阶的指令，你不再让 AI 自行推导实现路径，而是直接给出具体的执行步骤或约束 (W)。

回顾 Elie 老师的 7 条 prompt，它们至少都满足了 L1 的 “我要Z”。其中，第 1、2、6 条额外说明了现状 (Y)，而第 5、6 条则给出了具体的执行路径 (W)，属于更高阶的指令。

值得注意的是，最长的三条 prompt（1、3、7）都是预先编辑好再发送的，并且都巧妙地运用了 Markdown 的无序列表，甚至包含了层级关系。这种结构化的表达方式，极大地提升了信息传递的准确性，非常值得我们学习。

## 实践篇：三步为聊天机器人增添新翼

教程的核心是为一款已有的聊天机器人应用增加新功能。我们将跟随 Elie 老师的脚步，分三步完成这个任务：
1.  **功能一：为引用来源添加可点击链接**
2.  **功能二：添加 “新聊天” 按钮**
3.  **功能三：增强后端工具，获取更详细的课程信息**

### 第一战：计划先行，实现引用链接

**初始问题**：应用在回答问题时，会列出信息来源，但这些来源仅仅是纯文本，用户无法点击跳转。我们需要将其改造为可点击的超链接。

![source: https://www.anthropic.com/engineering/claude-code-best-practices](https://poketto.oss-cn-hangzhou.aliyuncs.com/bdddbf4f13bd7f82ae15a30a2b61df9e.png?x-oss-process=image/quality,q_90/rotate,0)

面对这样一个涉及前后端修改的任务，Elie 老师没有直接让 Claude Code 上手编码，而是采用了 [Claude Code 官方最佳实践](https://www.anthropic.com/engineering/claude-code-best-practices) 中首推的工作流：“先设计后编码 (Design then code)”。

```markdown

### 什么是计划模式 (Plan Mode)？

计划模式是 Claude Code 的一种特殊工作模式，特别适用于 **初次接触新功能、修复复杂 Bug 或进行代码重构** 的场景。通过按 `shift + tab` 切换进入。
其核心特点有二：
1.  **详尽思考**：AI 会投入更多的 “思考预算”，对任务进行更全面的分析和规划。
2.  **只读执行**：AI 不会直接修改你的文件，而是生成一份详细的修改计划和代码建议。只有在你明确授权后，它才会执行这些修改。
因此，计划模式是 **绝对安全** 的，并且 **生成的代码建议往往更优**。
```

AI 圈的大 V [宝玉老师也曾撰文探讨过这一模式](https://baoyu.io/blog/design-code-or-refactor-ai-simplifies)，他认为 AI 编程让 “先设计再写代码” 与 “先实现再重构” 之间的选择变得更加简单和灵活。

![source: https://claudelog.com/faqs/what-is-plan-mode](https://poketto.oss-cn-hangzhou.aliyuncs.com/b0f23352817f8dad03dd01d70fc4302b.png?x-oss-process=image/quality,q_90/rotate,0)

Elie 老师首先开启了计划模式，然后给出了一个高质量的 prompt，其中包含了：
*   **明确的目标**：构建一个带有来源引用的界面。
*   **精准的上下文**：通过 `@` 符号，直接引用了需要修改的前后端关键文件。

Claude Code 接收到指令后，并未立即生成代码，而是分析了相关文件，并提出了一份详尽的修改计划，清晰地列出了需要在哪些文件的哪个部分进行何种修改。在 Elie 老师确认计划可行后，Claude Code 才开始自动化地执行这些修改。

这个流程完美地展示了 “先计划，再编码” 的优势：方向明确，过程可控，结果可靠。

### 第二战：多模态交互与自动化调试

**第一阶段：视觉优化**
链接功能完成后，出现了一个新的 UI 问题：链接的默认蓝色在深色背景下难以辨认。

![初始UI问题：链接颜色难以辨认](https://poketto.oss-cn-hangzhou.aliyuncs.com/93af2d1de55ce19bd04ccca56a36e754.png?x-oss-process=image/quality,q_90/rotate,0)

这一次，Elie 老师展示了 Claude Code 强大的多模态能力。他直接截取了界面图片，粘贴到对话框中，并附言：“这些链接很难读，能让它更美观吗？”

这是一个非常直观高效的沟通方式。Claude Code 准确地识别了图片中的问题（“默认蓝色”），并迅速生成了修改 CSS 的代码。

**关于在 Claude Code 中使用图片，我有几点补充：**
*   在 Mac 上，粘贴图片的快捷键是 `Ctrl + V`，而不是常规的 `Cmd + V`，需要特别注意。
*   虽然图片沟通很直观，尤其是在前端调试中，但我更推荐进阶用户掌握更多 “降维到文本” 的沟通技巧。例如，我们可以使用 `code-inspector` 这类工具，它能让你在浏览器中点击任何一个前端组件，就直接在 VS Code 中定位到其源代码。然后，你可以把精确的代码位置信息告诉 Claude Code，这种方式在效率和准确性上，往往比截图更高。

**第二阶段：添加 “新聊天” 按钮与上下文管理**
接着，教程进入了下一个功能开发：添加一个 “新聊天” 按钮。

在开始新任务前，Elie 老师使用 `/clear` 命令清空了上下文。这是一个好习惯，可以避免旧的对话内容干扰新任务的执行。

但是，在我个人的实践中，我更倾向于使用 `/compact` 命令。

```markdown

### /clear vs. /compact

-   `/clear`：完全清空当前的对话历史和上下文。优点是干净利落，适用于完全不相关的任务切换。缺点是 AI 会丢失之前对话中形成的所有 “记忆” 和 “经验”。
-   `/compact`：压缩上下文，保留关键信息和对话摘要。优点是可以在开始新任务的同时，让 AI 记得一些重要的约束或偏好。
```

举个例子，在视频中，Elie 老师第一次告诉 AI 不要自动启动服务器，但在使用 `/clear` 并开始新任务后，AI 又忘记了这个指令。如果当时用的是 `/compact`，就大概率可以避免这个问题。**上下文工程 (Context Engineering)** 是当前大模型应用领域的一个核心课题，如何有效管理上下文，值得我们每个使用者深入研究。

**第三阶段：引入 MCP，实现自动化闭环**
“新聊天” 按钮的基本功能实现了，但样式仍然不尽人意。此时，手动截图、反馈、修改的循环显得有些繁琐。Elie 老师展示了 Claude Code 的王牌功能——通过 **模型上下文协议 (MCP)** 集成外部工具。

```markdown

### 模型上下文协议 (MCP)

MCP (Model Context Protocol) 是一套允许 Claude Code 等 AI 工具与外部数据源和系统进行交互的协议。通过 MCP，Claude Code 可以获得超越自身内置能力的 “超能力”，例如操作浏览器、读写文件系统、调用 API 等，从而成为一个真正意义上的智能体 (Agent)。
```

Elie 老师通过一行命令，为 Claude Code 添加了对 [Playwright](https://playwright.dev/) 的支持。

```bash
claude mcp add playwright npx @playwright/mcp@latest
```

![MCP成功连接Playwright](https://poketto.oss-cn-hangzhou.aliyuncs.com/02b10d404ee2b97e0470c745ac898150.png?x-oss-process=image/quality,q_90/rotate,0)

Playwright 是一个强大的浏览器自动化工具。集成之后，Claude Code 便拥有了自主操作浏览器的能力。Elie 老师随即下达了一个复杂的指令，要求 Claude Code：
1.  **访问** 页面。
2.  **查看** “新聊天” 按钮。
3.  **分析** 其样式与页面其他元素的差异。
4.  **修改** 代码，使其样式（对齐方式、边框等）与其他元素保持一致。

接下来发生的一幕令人印象深刻：
*   Claude Code 自动打开了一个新的浏览器窗口，访问了指定的页面。
*   它 “看” 到了页面布局，并 “理解” 了样式上的不一致。
*   它自动修改了相关的前端代码。
*   为了验证修改结果，它再次操作浏览器，刷新页面并进行二次 “视觉” 确认。

这个过程完全自动化，形成了一个 “观察-思考-行动-验证” 的闭环。这正是 “Highly Agentic” 的完美体现，也是 AI 辅助编程未来发展的方向。

### 第三战：深入后端，扩展 RAG 工具

完成了前端的开发，教程最后转向了后端。目标是为应用增加一个新工具，使其能够查询并返回更详细的课程信息（包括每一课的标题和描述）。

这本质上是在应用现有的 **检索增强生成 (Retrieval-Augmented Generation, RAG)** 系统中，注册一个新的工具。

```markdown

### 什么是 RAG？

RAG (Retrieval-Augmented Generation) 是一种将大型语言模型 (LLM) 与外部知识库相结合的技术框架。当用户提问时，系统首先从知识库（如数据库、文档集）中检索相关信息，然后将这些信息与原始问题一起提供给 LLM，让模型基于这些具体的、最新的知识来生成回答。教程中的应用就使用 RAG 来查询课程信息，而我们现在要做的，就是为这个系统增加一个新的信息检索 “工具”。
```

Elie 老师再次使用了 “计划模式”，让 Claude Code 分析现有的 `search_tools.py` 文件，并规划如何添加新工具。计划清晰地指出了三步：
1.  在 `search_tools.py` 中实现获取课程详细信息的新函数。
2.  更新系统提示词 (System Prompt)，告知模型新工具的存在和用法。
3.  在 RAG 系统中正式注册这个新工具。

计划通过后，Claude Code 精准地修改了 Python 代码和系统配置文件，成功为应用赋予了新的后端能力。

![最终成果：应用能够返回详细的课程信息](https://poketto.oss-cn-hangzhou.aliyuncs.com/5aeac1f2d9180b2f6eeb4236ae8770a0.png?x-oss-process=image/quality,q_90/rotate,0)

## 我的深度思考与工具链沉淀

除了教程本身的内容，我还想分享一些我在长期使用 Claude Code 及类似工具时，沉淀下来的一些更深层次的思考和个人工具集。

### Thinking Budget 与我的深度思考指令集

在 Google 的 AI Studio 中，有一个名为 `thinking budget` 的可调参数，它决定了模型在生成回答前进行内部思考的计算量。我发现在处理复杂任务时，将这个值调高，确实能获得质量更高的输出。

![Google AI Studio中的Thinking Budget](https://poketto.oss-cn-hangzhou.aliyuncs.com/f08ad92e2632a7952cdf0c336a460c0d.png?x-oss-process=image/quality,q_90/rotate,0)

Claude Code 虽然没有开放这个参数给用户调节，但官方文档中提到，我们可以通过 `think`, `think hard`, `think harder`, `ultrathink` 这四个关键词，来引导 Claude Code 使用更高的思考预算。

然而，在中文环境下，中英混用或纯中文输入这些指令，实测效果并不稳定。知名开发者王巍曾说：“凡是重复了两次以上的类似 prompt，都应该用命令来表述”。我深表赞同。因此，我很早就基于自研的 meta command，为 Claude Code 打造了一套深度思考的 slash commands set：

| Claude Code Mode | Slash Command | Shortcut | 适用场景 |
| :--- | :--- | :--- | :--- |
| normal | - | - | 常规任务 |
| think | `/think` | `/t` | 新增功能 |
| think hard | `/think-hard` | `/tt` | Bug 修复 |
| think harder | `/think-harder` | `/ttt` | 复杂 Bug 修复 |
| ultrathink | `/think-ultra` | `/tttt` | 大型重构 |

通过这套指令集，我可以非常方便地输入 `/tttt 重构用户认证模块`，从而以一种稳定、高效的方式，“PUA” Claude Code 尽最大努力去挑战一个复杂任务。这些命令是真实有效的，并且已经在多个开发者社群中得到了积极的反馈。

![胡博老师亲测有效](https://poketto.oss-cn-hangzhou.aliyuncs.com/c30968bcfb1eabb800c3d5a825464998.png?x-oss-process=image/quality,q_90/rotate,0)![我在上海AI Night的分享](https://poketto.oss-cn-hangzhou.aliyuncs.com/5782fa46dde7e790be2e72b9b6939a71.jpg?x-oss-process=image/quality,q_90/rotate,0)

### 在 Claude Code 中与文件共舞

在 Claude Code 中输入 `@` 即可引用文件，这极大地提升了提供上下文的效率。但经过我的测试，这里面有一些需要注意的 “坑”。

例如，在nextjs项目中，我们有时会使用带括号的文件夹代表 [路由组](https://nextjs.org/docs/app/api-reference/file-conventions/route-groups)，它的文件组织可能如下：

```
➜  ~/tmp tree
.
├── (dir2)
│   ├── file.md
│   └── test
│       └── file.md
├── dir1
│   ├── file.md
│   └── test
│       └── file.md
└── file.md

5 directories, 5 files


```

测试结果如下：

| 指令     | 候选结果                    | 是否符合预期   |
| ------ | ----------------------- | -------- |
| @file  | 全部五个文件                  | ✅        |
| @dir   | 全部两个文件夹与子文件             | ✅        |
| @dir1  | 全部两个文件夹与子文件             | ❌，数字被忽略了 |
| @dir2  | 全部两个文件夹与子文件，但dir3优先级变高了 | ❌，同上     |
| @dir1/ | dir1 文件夹与子文件            | ✅        |
| @dir2/ | 空                       | ❌，不能接受   |
| @test  | 全部两个 test 子文件夹，以及相应子文件  | ✅        |
| @test/ | 空                       | ❌，不能接受   |
|        |                         |          |

![](https://poketto.oss-cn-hangzhou.aliyuncs.com/35b3f0617fcb2f08fe293e26c7494234.png?x-oss-process=image/quality,q_90/rotate,0)


**结论与最佳实践**：
1.  **当路径中包含括号等特殊字符，并且你试图使用 `/` 进行路径导航时，自动补全会失效。**
2.  **直接输入不含特殊符号的目标文件名**，然后在候选列表中勾选，这是最稳妥的方式。
3.  如果候选文件太多，可以直接在文件管理器（如 Finder）中复制文件路径，然后粘贴到 Claude Code 中。
    *   **Tip**：在 macOS 的 Finder 中，右键点击文件，按住 `Option` 键，菜单中的 “拷贝” 就会变成 “**将‘文件名’拷贝为路径名称**”，非常方便。
4.  如果路径中有空格，记得用引号将路径包裹起来。

另外，值得一提的是 Claude Code 的文件读取策略。与许多套壳应用将文件内容直接嵌入 prompt 不同，Claude Code 采用的是更智能的 **“按需读取”** 策略。它仅在后续的分析中确实需要访问文件内部内容时，才会调用工具去读取文件。这种 Agentic 的行为模式，理论上可以带来更高的效率和更优的上下文利用率。

![Claude Code的按需读取策略](https://poketto.oss-cn-hangzhou.aliyuncs.com/c6ce60d58d53cc254e8108989e191ebe.png?x-oss-process=image/quality,q_90/rotate,0)

## 总结：拥抱 Agentic 编程新范式

本期吴恩达的 Claude Code 教程，与其说是一堂编程课，不如说是一次关于未来人机协作模式的预演。我们看到了一个真正 “Agentic” 的 AI 助手应该具备怎样的能力：

*   **深刻的理解力**：能通过自然语言、图片、代码文件等多种媒介，准确理解我们的意图。
*   **周密的规划力**：在行动前进行思考和规划，并征求我们的同意，确保方向的正确性。
*   **强大的执行力**：能直接修改代码，并自动化地完成一系列复杂操作。
*   **开放的扩展力**：能通过 MCP 等协议，与外部世界连接，不断扩展自己的能力边界。

作为开发者，我们需要适应这种新的协作范式。我们的角色正在从一个 “代码实现者” 转变为一个 “需求定义者”、“项目规划者” 和 “AI 监督者”。掌握如何精准地提出问题、如何有效地管理上下文、如何利用工具链增强 AI 的能力，这些 “软技能” 在 AI 时代将变得愈发重要。

希望我今天的分享，能为你带来一些启发。让我们一起在与 AI 共舞的道路上，不断探索，持续精进。

我是手工川，我们下期再见。